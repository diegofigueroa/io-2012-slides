<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
    <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
    <!--This one seems to work all the time, but really small on ipad-->
    <!--<meta name="viewport" content="initial-scale=0.4">-->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="stylesheet" media="all" href="theme/css/default.css">
    <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
    <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
    <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
  </head>
  <body style="opacity: 0">
    <slides class="layout-widescreen">

      <slide class="logoslide nobackground">
	<article class="flexbox vcenter">
	  <span><img src="images/ug.jpeg"></span>
	</article>
      </slide>
      
      <slide class="title-slide segue nobackground">
	<aside class="gdbar"><img src="images/ug_128.png"></aside>
	<!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
	<hgroup class="auto-fadein">
	  <h1 data-config-title><!-- populated from slide_config.json --></h1>
	  <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
	  <p data-config-presenter><!-- populated from slide_config.json --></p>
	</hgroup>
      </slide>
      
      
      <!-- Content starts HERE! -->
      
      
      
      <slide>
	<hgroup>
	  <h2>Top-down parsing</h2>
	</hgroup>
	<article>
	  <ul class="build">
	    <li>Un parser top-down, construye el arbol de parseo desde la raíz (desde arriba).</li>
	    <li>Cada nodo del arbol se obtiene haciendo derivaciones desde la izquierda (left-most derivation).</li><br/>
	    
	    <li>Dos implementaciones de este tipo:
	      <ul>
		<li>Recursive Descent</li>
		<li>Predictive Parser</li>
	      </ul>
	    </li>
	  </ul>
	</article>
      </slide>
      
       <slide class="segue dark nobackground">
	<aside class="gdbar"><img src="images/ug_128.png"></aside>
	<hgroup class="auto-fadein">
	  <h2>Top-down parsing</h2>
	  <h3>Recursive Descent</h3>
	</hgroup>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	</hgroup>
	<article>
	  <ul class="build">
	    <li>El arbol de parseo a generar inicia en el símbolo inicial de la gramática.</li>
	    <li>Intentamos obtener una derivacion (left-most derivation) utilizando la primera producción.</li><br/>
	    
	    <li>Después de n derivaciones, al obtener un terminal comparamos con el string de entrada:
	      <ul>
		<li>Si hacen match, avanzamos una posición.</li>
		<li>Si son distintos, intentamos con otra producción para el no terminal actual.</li>
	      </ul>
	    </li><br/>
	    
	    <li>Si en algún momento nos quedamos sin opciones, y el string generado no hace match con el input, el input es inválido.</li><br/>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article>
	  Gramática:
	  <ul>
	    <li>E -> T | T + E</li>
	    <li>T -> int | int * T | ( E )</li>
	  </ul>
	  Token stream:
	  <ul>
	    <li>( int )</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article>
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li><b class="red">E</b> -> T | T + E</li>
	      <li>T -> int | int * T | ( E )</li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  <b>E</b>
	  </pre>
	</article>
      </slide>
      
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article>
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li><b class="red">E -> T</b> | T + E</li>
	      <li>T -> int | int * T | ( E )</li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  E
		                                  |
		                                  T
	  </pre>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article>
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li>E -> T | T + E</li>
	      <li><b class="red">T -> int</b> | int * T | ( E )</li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  E
		                                  |
		                                  T
		                                  |
		                                 int
	  </pre>
	  <ul class="red build">
	    <li>¿ <b>int</b> hace match con <b>(</b> ?</li>
	    <li>¡NO!</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article>
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li>E -> T | T + E</li>
	      <li>T -> int | <b class="red">int * T</b> | ( E )</li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  E
		                                  |
		                                  T
	  </pre>
	  <ul class="red build">
	    <li>¿ int hace match con ( ?</li>
	    <li>¡NO!</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article>
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li>E -> T | T + E</li>
	      <li>T -> int | <b class="red">int * T</b> | ( E )</li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  E
		                                  |
		                                  T
		                               /  |  \
		                             int  *   T 
	  </pre>
	  <ul class="red build">
	    <li>¿ <b>int</b> hace match con <b>(</b> ?</li>
	    <li>¡NO!</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article>
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li>E -> T | T + E</li>
	      <li>T -> int | int * T | <b class="red">( E )</b></li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  E
		                                  |
		                                  T
		                               /  |  \
		                              (   E   ) 
	  </pre>
	  <ul class="build">
	    <li class="red">¿ <b>(</b> hace match con <b>(</b> ?</li>
	    <li class="green">¡SI!</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article>
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li>E -> T | T + E</li>
	      <li>T -> int | int * T | ( E )</li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">&nbsp;&nbsp;&nbsp;^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  E
		                                  |
		                                  T
		                               /  |  \
		                              (   E   ) 
	  </pre>
	  <ul class="build">
	    <li class="red">¿ <b>(</b> hace match con <b>(</b> ?</li>
	    <li class="green">¡SI!</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article>
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li><b class="red">E -> T</b> | T + E</li>
	      <li>T -> int | int * T | ( E )</li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">&nbsp;&nbsp;&nbsp;^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  E
		                                  |
		                                  T
		                               /  |  \
		                              (   E   ) 
		                                  |
		                                  T
	  </pre>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article class="smaller">
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li>E -> T | T + E</li>
	      <li><b class="red">T -> int</b> | int * T | ( E )</li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">&nbsp;&nbsp;&nbsp;^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  E
		                                  |
		                                  T
		                               /  |  \
		                              (   E   ) 
		                                  |
		                                  T
		                                  |
		                                 int
	  </pre>
	  <ul class="build">
	    <li class="red">¿ <b>int</b> hace match con <b>int</b> ?</li>
	    <li class="green">¡SI!</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article class="smaller">
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li>E -> T | T + E</li>
	      <li>T -> int | int * T | ( E )</li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  E
		                                  |
		                                  T
		                               /  |  \
		                              (   E   ) 
		                                  |
		                                  T
		                                  |
		                                 int
	  </pre>
	  <ul class="build">
	    <li class="red">¿ <b>)</b> hace match con <b>)</b> ?</li>
	    <li class="green">¡SI!</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article class="smaller">
	  <div class="columns-2">
	    <p>Gramática:</p>
	    <ul>
	      <li>E -> T | T + E</li>
	      <li>T -> int | int * T | ( E )</li>
	    </ul>
	    
	    <p>Input:</p>
	    <ul>
	      <li>( int ) </li>
	      <li><b class="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</b></li>
	    </ul>
	  </div>
	  <pre class="prettyprint">
		                                  E
		                                  |
		                                  T
		                               /  |  \
		                              (   E   ) 
		                                  |
		                                  T
		                                  |
		                                 int
	  </pre>
	  <ul class="build">
	    <li class="blue">Consumimos todo el input, y el arbol está completo.</li>
	    <li class="green">¡String aceptado!</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	  <h3>Nota</h3>
	</hgroup>
	<article class="smaller">
	  <div>A la acción de deshacer una o más derivaciones y regresar sobre el input se le llama <b>backtracking</b>.</div>
	</article>
      </slide>
      
      <slide class="segue dark nobackground">
	<aside class="gdbar"><img src="images/ug_128.png"></aside>
	<hgroup class="auto-fadein">
	  <h2>Top-down parsing</h2>
	  <h3>Recursive Descent (Implementación)</h3>
	</hgroup>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	</hgroup>
	<article>
	  <p>Implementado mediante una serie de funciones:</p>
	  <ul class="build">
	    <li><b>boolean term(Token t)</b>: Devuelve verdadero si el token actual del input es igual a t, además avanza el puntero.</li><br/>
	    <li>Para cada producción <b>n</b> de <b>S</b>:
	      <ul>
		<li><b>boolean Sn(){...}</b></li>
	      </ul>
	    </li><br/>
	    <li><b>boolean S(){}</b>: Devuelve verdadero si al menos una de <b>Si</b>...<b>Sn</b> devuelve verdadero.</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	</hgroup>
	<article>
	  <ul class="build">
	    <li>E -> T
	      <ul>
		<li>
		  <pre class="prettyprint" data-lang="java">boolean E1(){return T();}</pre>
		</li>
	      </ul>
	    </li>
	    <li>E -> T + E
	      <ul>
		<li>
		  <pre class="prettyprint" data-lang="java">boolean E2(){return T() && term(PLUS) && E();}</pre>
		</li>
	      </ul>
	    </li>
	    <li>
	      <ul>
		<li>
		  <pre class="prettyprint" data-lang="java">
boolean E(){
  Token prev = next;
  boolean success = E1();
  if(!success){
    next = prev;
    success = E2();
  }
  return success;
}</pre>
		</li>
	      </ul>
	    </li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent parsing</h2>
	</hgroup>
	<article class="smaller">
	  <ul class="build">
	    <li>T -> int
	      <ul>
		<li>
		  <pre class="prettyprint" data-lang="java">boolean T1(){return term(INT);}</pre>
		</li>
	      </ul>
	    </li>
	    <li>T -> int * T
	      <ul>
		<li>
		  <pre class="prettyprint" data-lang="java">boolean T2(){return term(INT) && term(TIMES) && T();}</pre>
		</li>
	      </ul>
	    </li>
	    <li>T -> ( E )
	      <ul>
		<li>
		  <pre class="prettyprint" data-lang="java">boolean T3(){return term(OPEN) && E() && term(CLOSE);}</pre>
		</li>
	      </ul>
	    </li>
	    <li>
	      <ul>
		<li>
		  <pre class="prettyprint" data-lang="java">
boolean T(){
  Token prev = next;
  boolean success = T1();
  if(!success){
    next = prev;
    success = T2();
    if(!success){
      next = prev;
      success = T3();
    }
  }
  return success;
}</pre>
		</li>
	      </ul>
	    </li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent</h2>
	  <h3>Conclusiones</h3>
	</hgroup>
	<article>
	  <ul class="build">
	    <li>Muy fácil de implementar.</li>
	    <li>No necesitamos herramientas automáticas que lo generen, podemos hacerlo manualmente.</li>
	    <li>Puede volverse lento, en función de cuánto backtracking necesite hacer.</li>
	  </ul>
	</article>
      </slide>
      
      <slide>
	<hgroup>
	  <h2>Recursive Descent</h2>
	  <h3>Ejemplo</h3>
	</hgroup>
	<article>
	  <ul class="build">
	    <li>S -> Sa</li>
	    <li>
              <pre class="prettyprint" data-lang="java">
boolean S1(){
  return S() && term(A);
}</pre>
	    </li>
	    <li>
              <pre class="prettyprint" data-lang="java">
boolean S(){
  return S1();
}</pre>
            </li>
            <li class="red"><b> ¿Ciclo infinito?</b></li>
	  </ul>
	</article>
      </slide>
      
      <slide class="segue dark nobackground">
        <aside class="gdbar"><img src="images/ug_128.png"></aside>
        <hgroup class="auto-fadein">
          <h2>Recursión Izquierda</h2>
        </hgroup>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Recursión Izquierda</h2>
        </hgroup>
        <article>
          <ul class="build">
            <li>La gramática anterior es un ejemplo de una gramática con recursión izquierda.</li><br/>
            <li>Una gramática con recursión izquierda es aquella que incluye alguna regla S tal que:</li>
            <li><pre class="prettyprint">S ->+ S &alpha;</pre></li>
            <br/>
            <li>Un parser recursive descent <b class="red">no</b> puede parsear una gramática con recursión izquierda.</li>
          </ul>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Recursión Izquierda</h2>
        </hgroup>
        <article>
          <ul class="build">
            <li><pre class="prettyprint">S -> S &alpha; | &beta;</pre></li>
            <li>¿Qué lenguaje acepta esta gramática?</li>
            <li>Todos los strings que inician con <b class="blue">&beta;</b> y terminan con una serie de <b class="blue">&alpha;</b>.</li><br/>
            <br/>
            <li class="red"><b>¿Qué pasa si reescribimos la gramática usando recursión derecha?</b></li>
            <li><pre>S  -> &beta; S'
S' -> &alpha; S' | &epsilon;</pre></li>
          </ul>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Recursión Izquierda</h2>
          <h3>Reescritura a Recursión Derecha</h3>
        </hgroup>
        <article>
          <ul class="build">
            <li><pre class="prettyprint">S -> S &alpha;1 | ... | S &alpha;n| &beta;1 | ... | &beta;m</pre></li>
            <br/>
            <li class="blue">Se puede reescribir como:</li>
            <li><pre>S  -> &beta;1 S' | ... | &beta;m S'
S' -> &alpha;1 S' | ... | &alpha;n S' | &epsilon;</pre></li>
          </ul>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Recursive Descent</h2>
          <h3>Conclusiones</h3>
        </hgroup>
        <article>
          <ul class="build">
            <li>Muy fácil de implementar.</li>
            <li>No necesitamos herramientas automáticas que lo generen, podemos hacerlo manualmente.</li>
            <li>Puede volverse lento, en función de cuánto backtracking necesite hacer.</li><br/>
            <li class="red"><b>Debemos eliminar la recursión izquierda antes del parseo!</b></li>
          </ul>
        </article>
      </slide>
      
      <slide class="segue dark nobackground">
        <aside class="gdbar"><img src="images/ug_128.png"></aside>
        <hgroup class="auto-fadein">
          <h2>Top-down parsing</h2>
          <h3>Predictive parser</h3>
        </hgroup>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Predictive parser</h2>
        </hgroup>
        <article>
          <ul class="build">
            <li>Similar a un parser recursive descent, pero con la capacidad de 'predecir' qué producción utilizar.</li>
            <li class="green">Esto significa que no necesita backtracking.</li>
            <li class="blue">Pero necesita <b>lookahead</b>.</li>
            <li><b>Lookahead</b>: Capacidad de ver los siguientes k tokens del token actual.</li><br/>
            <li class="red">Sólo puede aceptar un conjunto restringido de gramáticas.</li>
            <li>LL(k)
              <ul>
                <li>L   -> Left to right scanning (Lee el input de izquierda a derecha)</li>
                <li>L   -> Left-most derivation (Deriva únicamente el NT más a la izq.)</li>
                <li>(k) -> Cantidad de tokens de lookahead.</li>
                <li>Comúnmente, k = 1.</li>
              </ul>
            </li>
          </ul>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Predictive parser vs Recusive Descent</h2>
        </hgroup>
        <article>
          <ul class="build">
            <li>Recursive Descent
              <ul>
                <li>En cada paso debemos elegir la producción a utilizar.</li>
                <li>En caso de error, deshacemos la derivación (backtracking) e intentamos con la siguiente opción.</li>
              </ul>
            </li>
            <li>LL(1)
              <ul>
                <li>No es necesario escoger, en cada paso sólo tenemos una opción.</li>
                <li>Gracias al lookahead, que nos debe permitir determinar la producción a utilizar.</li>
              </ul>
            </li>
          </ul>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Predictive parser</h2>
          <h3>Ejemplo</h3>
        </hgroup>
        <article>
          <div class="columns-2">
            <p>Gramática:</p>
            <ul>
              <li>E -> T + E | T</li>
              <li>T -> int | int * T | ( E )</li>
              <br/>
            </ul>
            <p>Input:</p>
            <ul>
              <li>( int ) </li>
              <li>k=1</li>
            </ul>
          </div>
          <div>Queremos hacer una derivacion de <b class="blue">T</b>, sabemos que el próximo token es <b class="blue">int</b> (k = 1), cuál producción tomamos?</div><br/>
          <pre>T -> <b class="red">int</b> | <b class="red">int</b> * T | ( E )</pre>
          <div class="red">¡Hay 2 producciones para T que comienzan con el mismo símbolo!</div>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Factorización Izquierda</h2>
        </hgroup>
        <article>
          <ul class="build">
            <li>Si tenemos 2 o más producciones que comparten un prefijo en el RHS, podemos reescribir esas producciones para 'factorizar' ese prefijo.</li>
            <li><pre class="prettyprint">A -> &alpha; &beta;1 | &alpha; &beta;2</pre></li><br/>
            <li>Es equivalente a:</li>
            <li><pre>A -> &alpha; A'
A' -> &beta;1 | &beta;2
</pre></li><br/>
          </ul>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Factorización Izquierda</h2>
          <h3>Ejemplo</h3>
        </hgroup>
        <article>
            <pre class="prettyprint">E -> T + E | T
T -> int | int * T | ( E )
</pre>
          <p>Es equivalente a:</p>
          <pre>E -> T E'
E' -> + E | &epsilon;

T -> int | ( E )
T' -> * T | &epsilon;
</pre>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Predictive parsing</h2>
        </hgroup>
        <article>
          <ul class="build">
            <li>Un parser predictivo no soporta gramáticas con producciones factorizables por la izquierda.</li>
            <li>Debemos factorizar primero.</li>
            <li>Un parser predictivo, en vez de funcionar en base a funciones recursivas, utiliza una tabla de parseo.</li>
            <li>Esta tabla es un 'mapa' que le dice cómo moverse dado el no terminal del LHS de una producción y un símbolo del alfabeto.</li>
          </ul>
        </article>
      </slide>
      
       <slide>
        <hgroup>
          <h2>Predictive parsing</h2>
          <h3>Ejemplo</h3>
        </hgroup>
        <article>
          <pre class="prettyprint">E -> TX                                                     X -> + E | &epsilon;
T -> (E) | int Y                                            Y -> * T | &epsilon;
</pre>
	<table>
	    <tr>
	      <th></th><th>int</th><th>*</th><th>+</th><th>(</th><th>)</th><th>$</th>
	    </tr>
	    <tr>
	      <td>E</td><td>TX</td><td></td><td></td><td>TX</td><td></td><td></td>
	    </tr>
	    <tr>
	      <td>X</td><td></td><td></td><td>+ E</td><td></td><td>&epsilon;</td><td>&epsilon;</td>
	    </tr>
	    <tr>
	      <td>T</td><td>int Y</td><td></td><td></td><td>(E)</td><td></td><td></td>
	    </tr>
	    <tr>
	      <td>Y</td><td></td><td>* T</td><td>&epsilon;</td><td></td><td>&epsilon;</td><td>&epsilon;</td>
	    </tr>
	  </table>
        </article>
      </slide>
      
       <slide>
        <hgroup>
          <h2>Predictive parsing</h2>
          <h3>Ejemplo</h3>
        </hgroup>
        <article>
          <pre class="prettyprint">E -> TX                                                     X -> + E | &epsilon;
T -> (E) | int Y                                            Y -> * T | &epsilon;
</pre>
	<table>
	    <tr>
	      <th></th><th>int</th><th>*</th><th>+</th><th>(</th><th>)</th><th>$</th>
	    </tr>
	    <tr>
	      <td>E</td><td class="highlight">TX</td><td></td><td></td><td>TX</td><td></td><td></td>
	    </tr>
	    <tr>
	      <td>X</td><td></td><td></td><td>+ E</td><td></td><td>&epsilon;</td><td>&epsilon;</td>
	    </tr>
	    <tr>
	      <td>T</td><td>int Y</td><td></td><td></td><td>(E)</td><td></td><td></td>
	    </tr>
	    <tr>
	      <td>Y</td><td></td><td>* T</td><td>&epsilon;</td><td></td><td>&epsilon;</td><td>&epsilon;</td>
	    </tr>
	  </table>
	  <br/>
	  <div style="font-size:0.8em">Si queremos hacer una derivación para <b>E</b>, y el siguiente token es <b>int</b>, debemos usar: <b>E -> TX</b></div>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Predictive parsing</h2>
          <h3>Ejemplo</h3>
        </hgroup>
        <article>
          <pre class="prettyprint">E -> TX                                                     X -> + E | &epsilon;
T -> (E) | int Y                                            Y -> * T | &epsilon;
</pre>
	<table>
	    <tr>
	      <th></th><th>int</th><th>*</th><th>+</th><th>(</th><th>)</th><th>$</th>
	    </tr>
	    <tr>
	      <td>E</td><td>TX</td><td></td><td></td><td>TX</td><td></td><td></td>
	    </tr>
	    <tr>
	      <td>X</td><td></td><td></td><td class="highlight">+ E</td><td></td><td>&epsilon;</td><td>&epsilon;</td>
	    </tr>
	    <tr>
	      <td>T</td><td>int Y</td><td></td><td></td><td>(E)</td><td></td><td></td>
	    </tr>
	    <tr>
	      <td>Y</td><td></td><td>* T</td><td>&epsilon;</td><td></td><td>&epsilon;</td><td>&epsilon;</td>
	    </tr>
	  </table>
	  <br/>
	  <div style="font-size:0.8em">Si queremos hacer una derivación para <b>X</b>, y el siguiente token es <b>+</b>, debemos usar: <b>X -> + E</b></div>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Predictive parsing</h2>
          <h3>Ejemplo</h3>
        </hgroup>
        <article>
          <pre class="prettyprint">E -> TX                                                     X -> + E | &epsilon;
T -> (E) | int Y                                            Y -> * T | &epsilon;
</pre>
        <table>
            <tr>
              <th></th><th>int</th><th>*</th><th>+</th><th>(</th><th>)</th><th>$</th>
            </tr>
            <tr>
              <td>E</td><td>TX</td><td></td><td></td><td>TX</td><td></td><td></td>
            </tr>
            <tr>
              <td>X</td><td></td><td></td><td>+ E</td><td></td><td class="highlight">&epsilon;</td><td>&epsilon;</td>
            </tr>
            <tr>
              <td>T</td><td>int Y</td><td></td><td></td><td>(E)</td><td></td><td></td>
            </tr>
            <tr>
              <td>Y</td><td></td><td>* T</td><td>&epsilon;</td><td></td><td>&epsilon;</td><td>&epsilon;</td>
            </tr>
          </table>
          <br/>
          <div style="font-size:0.8em">Si queremos hacer una derivación para <b>X</b>, y el siguiente token es <b>)</b>, debemos usar: <b>X -> &epsilon;</b></div>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Predictive parsing</h2>
          <h3>Ejemplo</h3>
        </hgroup>
        <article>
          <pre class="prettyprint">E -> TX                                                     X -> + E | &epsilon;
T -> (E) | int Y                                            Y -> * T | &epsilon;
</pre>
	<table>
	    <tr>
	      <th></th><th>int</th><th>*</th><th>+</th><th>(</th><th>)</th><th>$</th>
	    </tr>
	    <tr>
	      <td>E</td><td>TX</td><td></td><td></td><td>TX</td><td></td><td></td>
	    </tr>
	    <tr>
	      <td>X</td><td></td><td class="highlight"></td><td>+ E</td><td></td><td>&epsilon;</td><td>&epsilon;</td>
	    </tr>
	    <tr>
	      <td>T</td><td>int Y</td><td></td><td></td><td>(E)</td><td></td><td></td>
	    </tr>
	    <tr>
	      <td>Y</td><td></td><td>* T</td><td>&epsilon;</td><td></td><td>&epsilon;</td><td>&epsilon;</td>
	    </tr>
	  </table>
	  <br/>
	  <div style="font-size:0.8em">Si queremos hacer una derivación para <b>X</b>, y el siguiente token es <b>*</b>: <b class="red">ERROR.</b></div>
        </article>
      </slide>
      
      <slide>
        <hgroup>
          <h2>Predictive parsing</h2>
          <h3>Parsing table</h3>
        </hgroup>
        <article class="smaller">
          <ul class="build">
            <li>Un parser predictivo utiliza la tabla de parseo para construir el arbol de parseo.</li>
            <li>Sigue un flujo similar al parser Recursive Descent:
              <ul>
                <li>Busca el no terminal más a la izquierda, 'N'.</li>
                <li>Revisa el siguiente token del input, 'a'.</li>
                <li class="blue">Busca la entrada en la tabla en la posición [N, a].</li>
                <li>Si existe una entrada, utiliza esa derivación para N.</li>
                <li>Si no existe, reporta error inmediatamente (no hay backtracking).</li>
              </ul>
            </li>
            <li>Utiliza un stack para guardar:
              <ul>
                <li>No terminales pendientes de derivar.</li>
                <li>Terminales a comparar contra el input.</li>
                <li>El tope del stack siempre contiene el siguiente símbolo (no-terminal o terminal) a trabajar.</li>
              </ul>
            </li>
            <li>Acepta un string cuando termina de recorrer el input, y no hay más símbolos en el stack.</li>
          </ul>
        </article>
      </slide>
      
      
      <slide>
        <hgroup>
          <h2>Predictive parsing</h2>
          <h3>Parsing table</h3>
        </hgroup>
        <article>
          <ul class="build">
            <li>Queremos construir una tabla de parseo tal que para un no terminal <b class="blue">A</b>, con una producción de la forma <b class="blue">A -> &alpha;</b>, y un token <b class="blue">t</b> del alfabeto:
            </li>
            <li><pre>T[A, t] = &alpha;</pre></li>
            <li>Para esto utilziaremos las funciones:
              <ul>
                <li>First</li>
                <li>Follow</li>
              </ul>
            </li>
          </ul>
        </article>
      </slide>
      
      <slide class="segue dark nobackground">
        <aside class="gdbar"><img src="images/ug_128.png"></aside>
        <hgroup class="auto-fadein">
          <h2>First</h2>
          <h3>Predictive Parser</h3>
        </hgroup>
      </slide>
      
      <slide>
        <hgroup>
          <h2>First</h2>
          <h3>Predictive parsing</h3>
        </hgroup>
        <article>
          <ul class="build">
            <li>Definición:</li>
            <li><pre class="prettyprint">First(&alpha;) = { t | &alpha; -> tX } U { &epsilon; | &alpha; -> &epsilon; }</pre></li>
          </ul>
          <ul class="build">
            <li>Reglas:</li>
            <li><pre class="prettyprint">First(t) = { t }</pre></li>
            <li><pre class="prettyprint">&epsilon; &isin; First(X)
 si: X -> &epsilon;
 ó:  X -> A1...An y &epsilon; &isin; First(Ai) para n = 1..n
</pre></li>
            <li><pre class="prettyprint">First(&alpha;) &sube; First(X)
 si: X -> A1..An &alpha;
 y:  E &isin; First(Ai) para i = 1..n
</pre></li>
          </ul>
        </article>
      </slide>
      
      
      
      <slide class="segue dark nobackground">
        <aside class="gdbar"><img src="images/ug_128.png"></aside>
        <hgroup class="auto-fadein">
          <h2>Follow</h2>
          <h3>Predictive Parser</h3>
        </hgroup>
      </slide>
      
      <slide class="logoslide dark nobackground">
      </slide>

      <slide class="backdrop"></slide>

    </slides>
    <!--[if IE]>
      <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
      <script>CFInstall.check({mode: 'overlay'});</script>
    <![endif]-->
  </body>
</html>
